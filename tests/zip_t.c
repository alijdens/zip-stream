/**
 * \file
 * ZIP compression - Tests.
 */

/* include area */
#include "scunit.h"
#include "zip.h"
#include <sys/wait.h>
#include <dirent.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>


/*-----------------------------------------------------------------------------
   Internal definitions
-----------------------------------------------------------------------------*/

/** Name of the output ZIP file. */
#define TMP_FILE "test.zip"

/** Name of the output ZIP file. */
#define TEST_DIR "zip_test/"

/** The size of the buffer used to write data. */
#define WRITE_BUFFER_SIZE 2048


/*-----------------------------------------------------------------------------
   Internal data
-----------------------------------------------------------------------------*/

/** Output file descriptor for the generated ZIP files. */
static int _fd = -1;


/*-----------------------------------------------------------------------------
   Helper functions
-----------------------------------------------------------------------------*/

/** Removes a directory and all it's contents.
 *
 *  \param path Path of the directory to remove.
 *  \return Used by the recursion.
 */
static int _remove_directory( const char *path )
{
  int r = -1;
  DIR *d = opendir( path );

  size_t path_len = strlen( path );
  if( d )
  {
    struct dirent *p;

    r = 0;

    while( !r && ( p = readdir( d ) ) )
    {
      int r2 = -1;
      char *buf;
      size_t len;

      /* skips "." and ".." */
      if( !strcmp( p->d_name, "." ) || !strcmp( p->d_name, ".." ) )
        continue;

      len = path_len + strlen( p->d_name ) + 2;
      buf = malloc( len );
      if( buf )
      {
        struct stat statbuf;

        snprintf( buf, len, "%s/%s", path, p->d_name );
        if( !stat( buf, &statbuf ) )
        {
          if( S_ISDIR( statbuf.st_mode ) )
            r2 = _remove_directory( buf );
          else
            r2 = unlink( buf );
        }

        free( buf );
      }

      r = r2;
    }

    closedir( d );

    if( !r )
      r = rmdir( path );
  }

  return r;
}


/** Stores Zipped data into \a TMP_FILE.
 *
 *  \param cb_ctx Unused.
 *  \param data Zipped data.
 *  \param data_len Zipped data length.
 *  \return \c false on error.
 */
static bool _zip_to_file( void *cb_ctx, const uint8_t *data, size_t data_len )
{
  return ( write( _fd, data, data_len ) == data_len );
}


/** Checks that the test ZIP file is correctly formatted.
 *
 *  \return \c false if it's not well formatted.
 */
static bool _test_zip( void )
{
  int stat = system( "unzip -tqq " TMP_FILE );

  /* checks the exit status was successful */
  return ( WEXITSTATUS( stat ) == EXIT_SUCCESS );
}


/** Extracts the test ZIP into the test directory (\a TEST_DIR).
 *
 *  \return \c false on error.
 */
static bool _unzip( void )
{
  /* removes the directory just in case */
  _remove_directory( TEST_DIR );

  /* extracts the contents of the test ZIP */
  int stat = system( "unzip -qq -d " TEST_DIR " " TMP_FILE );

  /* checks the exit status was successful */
  return ( WEXITSTATUS( stat ) == EXIT_SUCCESS );
}


/** Checks the contents of the ZIP generated by "Simple" test.
 *
 *  \return \c true if the contents matched the expected.
 */
static bool _check_zip_simple( void )
{
  if( !_unzip() )
    return false;

  int fd = open( TEST_DIR "data", O_RDONLY );
  if( fd < 0 )
    return false;

  bool rv = false;

  char expected[WRITE_BUFFER_SIZE] = { 'a' };
  char *obtained = malloc( WRITE_BUFFER_SIZE );

  for( size_t i = 0; i < 100; i++ )
  {
    if( read( fd, obtained, WRITE_BUFFER_SIZE ) != WRITE_BUFFER_SIZE )
      goto end;

    if( memcmp( expected, obtained, sizeof( expected ) ) != 0 )
      goto end;
  }

  if( read( fd, obtained, 1 ) != 0 )
    goto end;

  /* success */
  rv = true;

end:
  free( obtained );
  close( fd );
  return rv;
}


/** Checks the contents of the ZIP generated by "MultipleEntries" test.
 *
 *  \return \c true if the contents matched the expected.
 */
static bool _check_zip_multiple( void )
{
  if( !_unzip() )
    return false;

  bool rv = false;

  char *obtained = malloc( WRITE_BUFFER_SIZE );

  for( size_t i = 0; i < 5; i++ )
  {
    /* constructs the output filename */
    char fname[sizeof( TEST_DIR ) + 4 + 2] = TEST_DIR "data";
    fname[strlen( TEST_DIR ) + 4] = '0' + i;
    fname[strlen( TEST_DIR ) + 5] = 0;

    int fd = open( fname, O_RDONLY );
    if( fd < 0 )
    {
      printf( "%s not found", fname );
      goto end;
    }

    /* checks the contents of the file */
    char expected[WRITE_BUFFER_SIZE] = { 'a' + i };
    for( size_t i = 0; i < 100; i++ )
    {
      if( read( fd, obtained, WRITE_BUFFER_SIZE ) != WRITE_BUFFER_SIZE )
      {
        close( fd );
        goto end;
      }

      if( memcmp( expected, obtained, sizeof( expected ) ) != 0 )
      {
        close( fd );
        goto end;
      }
    }

    if( read( fd, obtained, 1 ) != 0 )
      goto end;

    close( fd );
  }

  /* success */
  rv = true;

end:
  free( obtained );
  return rv;
}


/** Deletes and creates the test file.
 *
 *  \return \c false on case of error.
 */
static bool _test_file_reset( void )
{
  if( _fd != -1 )
  {
    close( _fd );
    _fd = -1;
    remove( TMP_FILE );
  }

  _fd = open( TMP_FILE, O_CREAT | O_WRONLY | O_TRUNC, 0644 );
  return _fd > 0;
}



void SETUP( void )
{
  if( !_test_file_reset() )
  {
    printf( "Failed to reset test file\n" );
    exit( EXIT_FAILURE );
  }
}

void TEARDOWN( void )
{
  close( _fd );
  _fd = -1;
  remove( TMP_FILE );
  _remove_directory( TEST_DIR );
}


TEST( InvalidUsage )
{
  SETUP();

  zip_t z;
  ASSERT_TRUE( zip_init( &z, _zip_to_file, NULL ) );

  {
    /* no entry in progress */
    ASSERT_FALSE( zip_entry_update( &z, "data", 4 ) );
  }

  /* entry in progress */
  {
    ASSERT_TRUE( zip_entry_add( &z, "1", zip_get_datetime() ) );

    /* must end the entry first */
    ASSERT_FALSE( zip_end( &z ) );
  }

  ASSERT_TRUE( zip_entry_end( &z ) );

  zip_release( &z );

  TEARDOWN();
}

TEST( Empty )
{
  SETUP();

  /* just tests that the library doesn't crash, because it makes no sense to ZIP empty files */
  {
    /* creates an empty ZIP */
    zip_t z;
    ASSERT_TRUE( zip_init( &z, _zip_to_file, NULL ) );
    ASSERT_TRUE( zip_end( &z ) );
    zip_release( &z );

    /* not tested: throws a warning because the ZIP is empty */
    ASSERT_TRUE( _test_file_reset() );
  }
  {
    /* creates a ZIP with an empty entry */
    zip_t z;
    ASSERT_TRUE( zip_init( &z, _zip_to_file, NULL ) );
    ASSERT_TRUE( zip_entry_add( &z, "1", zip_get_datetime() ) );
    ASSERT_TRUE( zip_entry_end( &z ) );
    ASSERT_TRUE( zip_end( &z ) );
    zip_release( &z );

    ASSERT_TRUE( _test_zip() );
    ASSERT_TRUE( _test_file_reset() );
  }
  {
    /* creates a ZIP with multiple empty entries */
    zip_t z;
    ASSERT_TRUE( zip_init( &z, _zip_to_file, NULL ) );

    for( size_t i = 0; i < 10; i++ )
    {
      char name[2] = { '0' + i, 0 };
      ASSERT_TRUE( zip_entry_add( &z, name, zip_get_datetime() ) );
      ASSERT_TRUE( zip_entry_end( &z ) );
    }

    ASSERT_TRUE( zip_end( &z ) );
    zip_release( &z );

    ASSERT_TRUE( _test_zip() );
    ASSERT_TRUE( _test_file_reset() );
  }

  TEARDOWN();
}

TEST( MultipleEntries )
{
  SETUP();

  zip_t z;
  ASSERT_TRUE( zip_init( &z, _zip_to_file, NULL ) );

  for( size_t i = 0; i < 513; i++ )
  {
    char fname[2] = { '0' + i };

    ASSERT_TRUE( zip_entry_add( &z, fname, zip_get_datetime() ) );
    ASSERT_TRUE( zip_entry_end( &z ) );
  }

  ASSERT_TRUE( zip_end( &z ) );
  zip_release( &z );

  TEARDOWN();
}

TEST( Simple )
{
  SETUP();

  zip_t z;
  ASSERT_TRUE( zip_init( &z, _zip_to_file, NULL ) );
  ASSERT_TRUE( zip_entry_add( &z, "data", zip_get_datetime() ) );

  char data[WRITE_BUFFER_SIZE] = { 'a' };
  for( size_t i = 0; i < 100; i++ )
    ASSERT_TRUE( zip_entry_update( &z, data, sizeof( data ) ) );

  ASSERT_TRUE( zip_entry_end( &z ) );
  ASSERT_TRUE( zip_end( &z ) );
  zip_release( &z );

  ASSERT_TRUE( _test_zip() );
  ASSERT_TRUE( _check_zip_simple() );

  TEARDOWN();
}

TEST( MultipleEntriesWithUpdates )
{
  SETUP();

  zip_t z;
  ASSERT_TRUE( zip_init( &z, _zip_to_file, NULL ) );

  for( size_t i = 0; i < 5; i++ )
  {
    char fname[4 + 2] = "data";
    fname[4] = '0' + i;
    fname[5] = 0;

    ASSERT_TRUE( zip_entry_add( &z, fname, zip_get_datetime() ) );

    char data[WRITE_BUFFER_SIZE] = { 'a' + i };
    for( size_t i = 0; i < 100; i++ )
      ASSERT_TRUE( zip_entry_update( &z, data, sizeof( data ) ) );

    ASSERT_TRUE( zip_entry_end( &z ) );
  }

  ASSERT_TRUE( zip_end( &z ) );
  zip_release( &z );

  ASSERT_TRUE( _test_zip() );
  ASSERT_TRUE( _check_zip_multiple() );

  TEARDOWN();
}
